# Project Charter (PMBOK® Guide 6th – Process 4.1 Develop Project Charter)
## Dự án: Hệ thống quản lý **Order – Payment – Inventory** cho **Milk & Co – JW Marriott Hanoi** (40 chỗ ngồi)

> Tài liệu này được lập theo hướng dẫn **Project Charter** trong **PMBOK® Guide (6th Edition) – Knowledge Area: Project Integration Management – Process 4.1 Develop Project Charter**.

---

## 1) Thông tin tổng quan
- **Tên dự án:** Milk & Co OPS Suite (Order–Payment–Inventory)
- **Khách hàng/Receiving Organization:** Milk & Co – JW Marriott Hanoi (khu spa)
- **Mục tiêu kinh doanh:** Chuẩn hóa vận hành F&B quy mô nhỏ nhưng tiêu chuẩn cao cấp; giảm sai sót đơn hàng, kiểm soát thanh toán & tồn kho theo thời gian thực.
- **Độ ưu tiên:** Cao (liên quan doanh thu + trải nghiệm khách + kiểm soát thất thoát nguyên liệu)
- **Ngày dự kiến bắt đầu:** (TBD)
- **Thời lượng dự kiến:** 16 tuần (ước lượng ban đầu)

---

## 2) Sponsor, PM, và phân vai (Authority)
- **Project Sponsor (Khách hàng):** (TBD) – Quản lý vận hành/Director liên quan spa & F&B
- **Product Owner/Business Owner:** (TBD) – Đại diện nghiệp vụ nhà hàng
- **Project Manager (Bên triển khai):** (TBD)
- **Solution Architect (SA):** Bạn (Owner phần thiết kế giải pháp kỹ thuật end-to-end)
- **Tech Lead/Dev Lead:** (TBD)
- **QA Lead:** (TBD)
- **Đại diện IT/InfoSec khách sạn:** (TBD)

**Quyền hạn cấp cao (PMBOK 4.1):**
- Sponsor ủy quyền khởi động dự án, phê duyệt charter, phạm vi mức cao, ngân sách mức cao.
- PM chịu trách nhiệm lập kế hoạch chi tiết và điều phối thực thi.
- SA chịu trách nhiệm “solution direction”: kiến trúc, ràng buộc kỹ thuật, tích hợp, NFRs, rủi ro kỹ thuật.

---

## 3) Mục đích dự án và Business Case (Why)
### 3.1 Vấn đề hiện tại
- Quy trình đặt món/ghi nhận đơn thủ công hoặc rời rạc → dễ sai món, khó truy vết.
- Thanh toán đa kênh (thẻ/QR/cash/charge-to-room) → đối soát khó, rủi ro “thanh toán thành công nhưng đơn chưa cập nhật”.
- Tồn kho nguyên liệu kiểm thủ công → sai lệch, thất thoát, hết hàng đột ngột.

### 3.2 Lợi ích kỳ vọng
- Nâng trải nghiệm: order nhanh, ít nhầm, trạng thái minh bạch.
- Giảm rủi ro tài chính: thanh toán có audit trail, đối soát chuẩn.
- Kiểm soát chi phí: tồn kho theo thời gian thực, cảnh báo định mức.

---

## 4) Mục tiêu đo lường được & tiêu chí thành công (Measurable Objectives)
1. **Go-live MVP trong 12 tuần**, ổn định vận hành (tỷ lệ sự cố P1/P2 < 2 lần/tuần trong 4 tuần đầu).
2. **Giảm 30% thời gian xử lý đơn** (từ lúc tạo order đến lúc hoàn tất thanh toán) so với baseline.
3. **Sai lệch tồn kho < 3%** sau 1 chu kỳ kiểm kho chuẩn (định nghĩa chu kỳ: tuần/tháng – TBD).
4. **100% giao dịch thanh toán có thể truy vết**: từ Payment → Order → Inventory impact (audit log, correlation id).

---

## 5) Phạm vi mức cao (High-level Scope)
### 5.1 In-Scope
**A. Order**
- Tạo/sửa/hủy order; tách/gộp bàn; quản lý trạng thái (Draft/Confirmed/In-prep/Served/Closed).
- In bếp/bar (ticket), ghi chú dị ứng/ưu tiên.
- Khuyến mãi/coupon (nếu có) ở mức cơ bản.

**B. Payment**
- Thanh toán tiền mặt, thẻ, QR, ví điện tử; hỗ trợ “split bill”.
- Hỗ trợ quy trình **charge-to-room** (nếu JW cung cấp API/quy trình).
- Hoàn/huỷ giao dịch theo rule (TBD).
- Đối soát theo ca/ngày.

**C. Inventory**
- Danh mục nguyên liệu, định mức món (recipe), trừ kho theo order served/closed (rule do nghiệp vụ chốt).
- Nhập kho, xuất kho, kiểm kho, cảnh báo tồn tối thiểu.
- Báo cáo tồn, tiêu hao, thất thoát (cơ bản).

**D. Báo cáo vận hành**
- Doanh thu theo ngày/ca/method; top món; cảnh báo hết hàng.

### 5.2 Out-of-Scope (giai đoạn này)
- Tích hợp ERP phức tạp toàn khách sạn (trừ khi bắt buộc).
- Loyalty/CRM nâng cao.
- Machine learning dự báo nhu cầu.

---

## 6) Deliverables mức cao
- Ứng dụng Order (tablet/web) cho nhân viên
- Payment module + đối soát
- Inventory module + recipe & trừ kho
- Admin portal cấu hình & báo cáo
- Tài liệu vận hành + đào tạo
- Bộ tài liệu kỹ thuật (API spec, ADRs, runbook)

---

## 7) Milestones mức cao (ước lượng ban đầu)
1. **Initiation + Discovery (Tuần 1–2):** workshop nghiệp vụ, baseline KPI, chốt scope MVP
2. **Architecture & UX skeleton (Tuần 2–3):** kiến trúc mức cao, prototype luồng chính
3. **Build MVP (Tuần 4–10):** order + payment + inventory core
4. **Pilot onsite (Tuần 11–12):** chạy thử 1–2 ca/ngày, fix nhanh
5. **Go-live (Tuần 13):** triển khai chính thức
6. **Hypercare (Tuần 14–16):** theo dõi, tối ưu, bàn giao

---

## 8) Giả định & ràng buộc (Assumptions & Constraints)
### 8.1 Giả định
- Khách hàng cung cấp đại diện nghiệp vụ tham gia workshop tối thiểu 2–3 buổi/tuần trong 2 tuần đầu.
- Có thiết bị vận hành (tablet/PC/ printer) hoặc thống nhất phương án mua sắm.
- Nếu có charge-to-room: JW cung cấp quy trình/API hoặc tài liệu tích hợp.

### 8.2 Ràng buộc
- Bảo mật thanh toán theo chính sách khách sạn; dữ liệu nhạy cảm không lưu trữ trái phép.
- Hệ thống cần hoạt động ổn định trong môi trường mạng nội bộ khách sạn (có thể chập chờn).

---

## 9) Rủi ro mức cao (High-level Risks)
- **Tích hợp payment/charge-to-room** không có API rõ ràng → phát sinh effort hoặc thay đổi scope.
- **Mạng onsite không ổn định** → cần chiến lược offline/queue/đồng bộ.
- **Sai lệch rule trừ kho** (trừ theo served vs closed) → ảnh hưởng báo cáo; cần thống nhất sớm.
- **Vận hành đa vai** (nhân viên ít, nhiều nhiệm vụ) → UX cần cực tối giản, giảm thao tác.

---

# 10) Solution Architect Direction

> Cung cấp đủ định hướng kỹ thuật, NFR và rủi ro kỹ thuật (charter nêu yêu cầu mức cao, rủi ro mức cao, giả định, ràng buộc, và ủy quyền).

## 10.1 Architecture Vision (tầm nhìn kiến trúc – mức charter)
### a) Nguyên tắc thiết kế (Design Principles)
- **Single source of truth** cho trạng thái Order/Payment/Inventory.
  - Liên hệ nguyên lý/mẫu kiến trúc: Single Source of Truth (SSoT) là nguyên tắc dữ liệu trong đó mỗi thông tin chỉ có một nơi lưu trữ duy nhất đóng vai trò nguồn dữ liệu chính thức. Điều này loại bỏ mâu thuẫn và đảm bảo mọi thành phần sử dụng cùng một dữ liệu đáng tin cậy. Ví dụ, hệ thống Inventory nên có một cơ sở dữ liệu trung tâm làm nguồn sự thật duy nhất về tồn kho, sau đó đồng bộ tới các dịch vụ hoặc module khác khi cần. Nguyên lý này thường đi kèm với các mẫu như Event Sourcing, trong đó mọi thay đổi trạng thái được lưu thành sự kiện bất biến trong một event store đóng vai trò hệ thống nguồn của dữ liệu hiện tại.
  - Cách triển khai trong hệ thống: Ứng dụng nguyên tắc SSoT, ta phân tách rõ quyền sở hữu dữ liệu cho từng domain: Order, Payment, Inventory. Mỗi dịch vụ (hoặc module) có cơ sở dữ liệu riêng và chịu trách nhiệm làm nguồn sự thật cho trạng thái của mình – ví dụ, chỉ Inventory service được phép cập nhật lượng tồn kho, các service khác chỉ đọc hoặc yêu cầu thay đổi thông qua Inventory service. Khi Order mới được tạo, hệ thống không tạo bản sao trạng thái của Inventory hay Payment ở nhiều nơi; thay vào đó, Order service sẽ gọi hoặc chờ sự kiện từ Inventory service để lấy thông tin tồn kho chính xác. Các thành phần được tích hợp qua API hoặc sự kiện bảo đảm dữ liệu luôn xuất phát từ nguồn đáng tin cậy duy nhất. Cách tiếp cận này cũng có thể kết hợp với CQRS – các service duy trì bản sao chỉ-đọc (read model) cho truy vấn nhanh, nhưng mọi cập nhật vẫn phải đi qua nguồn sự thật duy nhất của từng domain.
  - Đáp ứng mục tiêu phi chức năng: Thiết kế SSoT giúp độ tin cậy và tính nhất quán dữ liệu cao hơn do tránh được sai lệch giữa nhiều bản ghi. Không còn tình trạng dữ liệu xung đột phải đối chiếu thủ công, nhờ đó giảm rủi ro lỗi và chi phí bảo trì. Ví dụ, nếu chỉ dùng một nguồn tồn kho duy nhất, hệ thống sẽ tránh được scenario “overselling” (bán quá số lượng tồn kho) do tất cả các đơn hàng đều kiểm tra và cập nhật cùng một kho dữ liệu. Về tính sẵn sàng, một nguồn dữ liệu trung tâm đồng nghĩa với việc cần thiết kế sao cho không có điểm lỗi đơn lẻ – có thể triển khai replica hoặc cluster cho database nguồn để hệ thống vẫn hoạt động nếu node chính gặp sự cố. Bên cạnh đó, SSoT tạo thuận lợi cho quan sát và audit: khi cần kiểm tra trạng thái Order/Payment/Inventory, chỉ cần truy vấn nguồn duy nhất; mọi thay đổi đều được theo dõi tập trung, giúp việc hỗ trợ và debug nhanh chóng hơn.
- **Idempotency by design** cho thao tác Payment (tránh bấm “Pay” nhiều lần).
  - Liên hệ nguyên lý/mẫu kiến trúc: Idempotency là thuộc tính của thao tác cho phép thực hiện lặp lại nhiều lần mà kết quả như nhau như chỉ thực hiện một lần. Nguyên tắc này cực kỳ quan trọng trong các hệ thống phân tán và đặc biệt là xử lý thanh toán: nó đảm bảo một yêu cầu thanh toán lặp lại sẽ không gây ra khoản thu tiền trùng lặp. Ví dụ, nếu dịch vụ Payment nhận hai yêu cầu giống nhau, idempotency đảm bảo chỉ trừ tiền một lần và giữ dữ liệu tài chính chính xác. Nguyên lý này thường được thiết kế sẵn bằng cách sử dụng mã giao dịch duy nhất hoặc khóa idempotency cho mỗi thanh toán. Trong kiến trúc hướng sự kiện, các consumer cũng được xây dựng theo mẫu Idempotent Consumer, nghĩa là sẵn sàng xử lý sự kiện trùng lặp mà không gây thay đổi thêm nếu sự kiện đã được xử lý trước đó.
  - Cách triển khai trong hệ thống: Đối với dịch vụ Payment, ta thiết kế mọi API và xử lý thanh toán có tính idempotent. Cụ thể, mỗi giao dịch thanh toán (ví dụ gắn với Order ID hoặc một Payment ID duy nhất) sẽ được gắn một định danh duy nhất; Payment service sẽ lưu trạng thái giao dịch này. Khi nhận được yêu cầu xử lý hoặc sự kiện thanh toán, service sẽ kiểm tra ID: nếu giao dịch đã thực hiện trước đó thì bỏ qua hoặc trả về kết quả đã có, tránh xử lý lại. Chẳng hạn, Payment service có thể lưu một bản ghi “đã thanh toán” kèm PaymentID; mọi lần nhận yêu cầu với PaymentID đó sẽ được nhận diện và bỏ qua. Tương tự, khi tích hợp qua sự kiện, các sự kiện Payment cũng chứa transaction ID để Inventory hay Order service nhận biết và bỏ qua nếu đã áp dụng. Việc này có thể được hỗ trợ bởi một cơ chế lưu vết ID đã xử lý (cache hoặc bảng log) trong từng service. Theo khuyến nghị thiết kế saga, các dịch vụ nên “đảm bảo idempotency của sự kiện” bằng cách dùng mã giao dịch duy nhất để nhận dạng và xử lý trơn tru trường hợp trùng lặp. Ngoài ra, khi gọi các API bên ngoài (cổng thanh toán chẳng hạn), hệ thống cũng gửi kèm khóa idempotency để phía thứ ba không thực hiện trùng lặp giao dịch.
  - Đáp ứng mục tiêu phi chức năng: Thiết kế idempotent nâng cao độ tin cậy và toàn vẹn dữ liệu cho hệ thống. Trước hết, nó ngăn ngừa các lỗi nghiêm trọng như double charge (trừ tiền hai lần) hoặc tạo trùng lặp đơn hàng – những sự cố gây tổn hại uy tín và phải xử lý thủ công tốn kém. Nhờ idempotency, hệ thống có thể tự tin retry các thao tác khi gặp lỗi mạng hoặc dịch vụ tạm thời gián đoạn mà không sợ hậu quả bất nhất. Điều này cải thiện khả năng chịu lỗi và độ sẵn sàng: nếu một yêu cầu thanh toán thất bại do lỗi mạng, hệ thống có thể gửi lại yêu cầu mà vẫn đảm bảo chỉ một lần thanh toán được ghi nhận. Hơn nữa, idempotency hỗ trợ khả năng mở rộng: các thành phần có thể xử lý song song hoặc lặp lại thông điệp mà không làm hỏng trạng thái, cho phép hệ thống linh hoạt scale-out mà vẫn giữ ổn định. Tóm lại, tính idempotent giúp hệ thống Payment an toàn hơn trước các sự cố và dễ dàng bảo trì hơn, bởi vì mọi thao tác đều có kết quả xác định và không gây tác dụng phụ ngoài ý muốn.
- **Eventual consistency có kiểm soát** giữa Payment ↔ Order ↔ Inventory, luôn có audit trail.
  - Liên hệ nguyên lý/mẫu kiến trúc: Eventual Consistency là mô hình nhất quán phổ biến trong kiến trúc microservices: các dịch vụ không khóa chặt giao dịch phân tán tức thì, thay vào đó cập nhật cục bộ và dần dần đồng bộ với nhau thông qua sự kiện. Mẫu Saga pattern áp dụng nguyên lý này để đảm bảo dữ liệu sẽ nhất quán khi toàn bộ chuỗi công việc hoàn tất, mặc dù tại mỗi thời điểm trung gian có thể tạm thời chưa đồng bộ. Saga phân tán một giao dịch lớn thành nhiều giao dịch nhỏ ở từng service và sử dụng event hoặc orchestrator để phối hợp; nhờ đó hệ thống đạt được nhất quán cuối cùng mà không cần khóa phân tán. Bên cạnh đó, Event-Driven Architecture (EDA) cũng là nền tảng cho eventual consistency: các service phát và tiêu thụ sự kiện để phản ứng với thay đổi trạng thái của nhau. Để đảm bảo tính đúng đắn, saga/EDA thường đi kèm với các bước bù (compensating transactions) khi lỗi xảy ra, nhằm đưa hệ thống về trạng thái nhất quán. Một khía cạnh trọng yếu khác là Audit Trail: mọi thay đổi trạng thái nên được ghi nhật ký bất biến. Mẫu Event Sourcing là ví dụ tiêu biểu, khi mọi sự kiện (như OrderCreated, InventoryReserved, PaymentFailed…) đều được lưu vào event store dạng append-only, tạo thành một chuỗi log sự kiện đầy đủ để giám sát và có thể phát lại trạng thái hệ thống.
  - Cách triển khai trong hệ thống: Hệ thống Order–Payment–Inventory có thể đạt eventual consistency bằng cách tích hợp không đồng bộ qua sự kiện thay vì gọi đồng bộ trực tiếp. Ví dụ, khi khách đặt Order, Order service tạo đơn hàng mới ở trạng thái “Pending” và phát ra một sự kiện OrderCreated. Payment service nhận sự kiện này, tiến hành xử lý thanh toán (giao dịch local) rồi phát PaymentSucceeded hoặc PaymentFailed. Inventory service lắng nghe sự kiện thanh toán để quyết định trừ kho hay phục hồi kho tương ứng. Các service vận hành cục bộ, trao đổi qua message broker (như Kafka) đảm bảo loose coupling và không cần lock global. Để kiểm soát consistency, ta có thể chọn cách Saga orchestration: một Orchestrator service tuần tự gọi Order → Payment → Inventory và gọi các action bù nếu một bước thất bại (ví dụ, nếu Payment thất bại thì orchestrator sẽ ra lệnh hủy Order). Ở quy mô nhỏ (40 chỗ ngồi), phương án Choreography (phát sự kiện không cần trung tâm điều phối) cũng hiệu quả, miễn là các dịch vụ xử lý đúng logic và thứ tự sự kiện. Mẫu Transactional Outbox nên được áp dụng để đảm bảo mỗi sự kiện được lưu và gửi đi một cách tin cậy cùng với giao dịch dữ liệu: khi một service cập nhật database, sự kiện mô tả thay đổi đó được ghi vào bảng outbox trong cùng transaction, sau đó một tiến trình nền sẽ đọc outbox và xuất sự kiện ra message broker. Cách này đảm bảo không có sự kiện nào bị mất ngay cả khi service gặp sự cố, đồng thời tách biệt hẳn việc gửi thông điệp khỏi logic nghiệp vụ, giúp hệ thống chịu lỗi tốt hơn. Toàn bộ các sự kiện và thao tác quan trọng cũng cần được ghi log audit. Mỗi service có thể lưu lịch sử trạng thái (như log Order state changes, Payment attempts, Inventory adjustments) hoặc gửi các sự kiện audit tới một kho chung. Nhờ vậy, bất kỳ lúc nào cũng có thể kiểm tra dòng sự kiện để biết hệ thống đang ở đâu, và có dữ liệu truy vết để so sánh trạng thái giữa các service nếu phát hiện bất nhất.
  - Đáp ứng mục tiêu phi chức năng: Kiến trúc nhất quán cuối cùng với saga và audit trail được thiết kế để tối ưu độ tin cậy và khả năng chịu lỗi của hệ thống đa dịch vụ. Thứ nhất, saga cho phép hệ thống xử lý thất bại cục bộ một cách an toàn: nếu một bước trong quy trình (Payment hoặc Inventory) lỗi, các giao dịch đã hoàn thành trước đó sẽ được rollback bằng thao tác bù tương ứng (ví dụ: nếu thanh toán thành công nhưng trừ kho thất bại, hệ thống sẽ hoàn tiền cho khách hàng). Nhờ vậy, dữ liệu toàn cục vẫn nhất quán (đơn hàng sẽ bị hủy nếu thanh toán lỗi, kho hàng giữ nguyên, không ai bị mất tiền oan). Thứ hai, tính eventual consistency giúp tăng tính sẵn sàng và khả năng mở rộng: các service không bị khóa chờ nhau, nên mỗi thành phần có thể hoạt động độc lập và scale theo nhu cầu. Hệ thống chấp nhận một độ trễ nhỏ để đồng bộ dữ liệu nhưng tránh được việc dùng transaction phân tán nặng nề (như 2PC) vốn kém mở rộng và giảm availability. Thứ ba, audit trail đầy đủ từ log sự kiện giúp nâng cao observability và maintainability: ta có thể theo dõi mọi hành động đã diễn ra đối với đơn hàng, thanh toán, tồn kho – hỗ trợ đắc lực khi cần debug hoặc kiểm toán. Chẳng hạn, nhờ outbox/event log, tất cả sự kiện cùng timestamp và trạng thái đều lưu vết rõ ràng, giúp hệ thống dễ dàng kiểm tra, tái hiện lại diễn biến và đảm bảo không bị mất dữ liệu nào. Ngoài ra, audit trail cũng góp phần vào bảo mật và tuân thủ (có log để phát hiện hành vi bất thường hoặc phục vụ điều tra sau này). Tóm lại, kiến trúc hướng sự kiện với nhất quán cuối cùng có kiểm soát mang lại độ tin cậy cao (vừa linh hoạt chịu lỗi, vừa không hy sinh dữ liệu), đảm bảo hệ thống Order–Payment–Inventory hoạt động trơn tru ngay cả trong trường hợp lỗi và cung cấp đầy đủ minh bạch về trạng thái hệ thống.
- **Security-first**: phân quyền, logging, bảo vệ dữ liệu nhạy cảm.
  - Liên hệ nguyên lý/mẫu kiến trúc: Security-first design đòi hỏi tích hợp các biện pháp bảo mật ngay từ khi thiết kế, thay vì bổ sung sau. Các nguyên tắc tiêu biểu bao gồm Principle of Least Privilege – giới hạn quyền truy cập của mỗi người dùng/dịch vụ chỉ ở mức cần thiết cho nhiệm vụ của họ. Điều này đảm bảo ngay cả khi một tài khoản bị xâm nhập, thiệt hại cũng được giảm thiểu. Bên cạnh đó là chiến lược Defense in Depth – triển khai nhiều lớp phòng thủ (ví dụ: xác thực, phân quyền, mã hóa, firewall, IDS/IPS, v.v.) để nếu một lớp bị lọt, lớp khác vẫn bảo vệ được hệ thống. Mặc định hệ thống nên ở trạng thái Secure by Default: các cấu hình nhạy cảm được khóa an toàn, yêu cầu mật khẩu mạnh, truyền thông mã hóa... Việc logging/auditing cũng được coi là một phần của thiết kế bảo mật (để giám sát và phát hiện sớm bất thường), tuy nhiên phải tuân thủ nguyên tắc không phơi bày dữ liệu nhạy cảm trong log.
  - Cách triển khai trong hệ thống: Áp dụng security-first cho Milk & Co Order–Payment–Inventory, trước tiên cần thiết kế phân quyền chặt chẽ (RBAC) cho các vai trò: ví dụ, nhân viên phục vụ có thể tạo Order nhưng không truy cập được chức năng hoàn tiền Payment; quản lý có quyền cao hơn như phê duyệt refund, điều chỉnh Inventory, v.v. Mỗi request tới hệ thống đều phải được xác thực (authentication) và ủy quyền (authorization) đúng vai trò. Có thể dùng JWT hoặc OAuth2 để truyền thông tin người dùng và quyền hạn giữa các service một cách an toàn. Với dữ liệu nhạy cảm (như thông tin thẻ tín dụng khách hàng, thông tin cá nhân), hệ thống cần bảo vệ nghiêm ngặt: chẳng hạn, không lưu trực tiếp số thẻ tín dụng – thay vào đó lưu token đã mã hóa hoặc mã tham chiếu từ cổng thanh toán. Dữ liệu nhạy cảm trong DB nên được mã hóa (Encryption at Rest) và luôn truyền qua TLS để đảm bảo Encryption in Transit. Logging được triển khai để ghi lại các sự kiện quan trọng (đăng nhập, thanh toán, thay đổi phân quyền, v.v.) phục vụ audit bảo mật, nhưng tuân thủ quy tắc không ghi thông tin nhạy cảm ở dạng rõ. Ví dụ, log có thể chứa OrderID, thời gian, user thực hiện, nhưng không ghi trực tiếp số thẻ hay mật khẩu (các thông tin này nếu cần thì chỉ giữ hash/ẩn một phần). Ngoài ra, cần cơ chế theo dõi và cảnh báo: tích hợp log tập trung (SIEM) để phát hiện đăng nhập thất bại nhiều lần, hành vi bất thường; sử dụng các thư viện chống SQL injection, CSRF, và thường xuyên cập nhật bản vá bảo mật. Về hạ tầng, nếu hệ thống triển khai on-premise tại JW Marriott, cần đảm bảo máy chủ được cập nhật, cấu hình firewall chỉ mở cổng dịch vụ cần thiết, và vật lý an ninh (khóa, camera) cho thiết bị tại chỗ. Tất cả những biện pháp này đòi hỏi được thiết kế đồng bộ ngay từ đầu để tạo nên một kiến trúc “security by design” toàn diện.
  - Đáp ứng mục tiêu phi chức năng: Bảo mật được ưu tiên từ thiết kế sẽ bảo vệ các mục tiêu phi chức năng cốt lõi như tính toàn vẹn, bí mật và sẵn sàng của hệ thống. Nhờ phân quyền chặt chẽ và nguyên tắc least privilege, nguy cơ lạm dụng hoặc truy cập trái phép được giảm thiểu đáng kể – góp phần giữ cho dữ liệu đơn hàng, thanh toán, tồn kho không bị sửa đổi hay rò rỉ bởi người không có thẩm quyền. Việc bảo vệ dữ liệu nhạy cảm (mã hóa, ẩn thông tin) và kiểm soát chặt đầu vào (như chống SQLi, XSS) giúp duy trì tính toàn vẹn của hệ thống trước các cuộc tấn công phổ biến. Logging đầy đủ kết hợp với audit trail giúp nâng cao observability về mặt bảo mật – mọi thao tác quan trọng đều có dấu vết, cho phép phát hiện sớm hành vi bất thường và hỗ trợ điều tra sự cố (non-repudiation). Điều này cũng tăng độ tin cậy: nếu có sự cố xảy ra (như giao dịch gian lận hoặc rò rỉ), đội ngũ kỹ thuật có thông tin để phản ứng nhanh, giảm thời gian khắc phục (MTTR). Các biện pháp bảo mật cũng bảo vệ độ sẵn sàng của dịch vụ – ví dụ chặn trước tấn công DoS/DDoS, đảm bảo hệ thống không bị gián đoạn bởi sự cố an ninh. Về lâu dài, security-first giúp hệ thống dễ bảo trì và mở rộng mà không lo “vá” các lỗ hổng nghiêm trọng, đồng thời tạo niềm tin cho khách hàng và đối tác (đặc biệt quan trọng trong xử lý thanh toán). Tóm lại, một kiến trúc coi bảo mật là ưu tiên hàng đầu sẽ vận hành ổn định, ít sự cố và sẵn sàng đáp ứng các yêu cầu tuân thủ (như PCI-DSS cho thanh toán), tạo nền tảng vững chắc cho hệ thống Order–Payment–Inventory.
- **Operability**: quan sát được (logs/metrics/traces), dễ hỗ trợ onsite.
  - Liên hệ nguyên lý/mẫu kiến trúc: Operability đề cập đến khả năng vận hành và giám sát hệ thống một cách hiệu quả, đặc biệt quan trọng đối với hệ thống triển khai thực tế (on-premises) như ở nhà hàng Milk & Co. Nguyên tắc chính là xây dựng hệ thống có Observability cao – tức là dễ dàng hiểu được trạng thái bên trong thông qua các đầu ra bên ngoài như log, số liệu đo (metrics) và dấu vết (traces). Đây được xem là “3 trụ cột” của quan sát hệ thống: log cung cấp lịch sử sự kiện và lỗi, metrics cho thấy các chỉ số hiệu năng theo thời gian, còn distributed trace cho phép lần theo hành trình của một yêu cầu qua các service để tìm điểm nghẽn. Kiến trúc hiện đại (theo triết lý DevOps/SRE) coi monitoring & observability là thành phần thiết yếu, giúp cho đội ngũ vận hành có dữ liệu kịp thời để chẩn đoán và xử lý sự cố. Bên cạnh đó, nguyên tắc operability khuyến khích thiết kế hệ thống đơn giản, dễ hiểu và dễ thao tác đối với kỹ sư vận hành tại chỗ: ví dụ cấu hình bằng code rõ ràng, có dashboard quản trị trực quan, và quy trình triển khai hoặc khôi phục sự cố không quá phức tạp. Mẫu hình như Health Check Endpoint, Centralized Logging, Distributed Tracing nên được áp dụng để hiện thực hóa các mục tiêu trên.
  - Cách triển khai trong hệ thống: Để hệ thống quan sát được và hỗ trợ vận hành tại chỗ, trước tiên ta triển khai hệ thống logging tập trung. Mỗi service (Order, Payment, Inventory) sẽ ghi log có cấu trúc (structured logs) bao gồm timestamp, level, thông tin ngữ cảnh (ví dụ OrderID, user...) cho mỗi request hoặc sự kiện quan trọng. Các log này được chuyển về một kho log tập trung (có thể là Elastic Stack hoặc dịch vụ cloud nếu cho phép) để team IT tại chỗ có thể dễ dàng tra cứu khi cần hỗ trợ. Song song, tích hợp metrics cho từng service: ví dụ Order service thu thập số lượng đơn tạo mỗi phút, Payment service đo thời gian xử lý giao dịch trung bình, Inventory service theo dõi mức tồn kho và số lần restock. Các metrics này được hiển thị trên dashboard (ví dụ Grafana) đặt tại quầy quản trị hoặc phòng IT, giúp nhân viên thấy ngay sức khỏe hệ thống (CPU, memory, throughput, error rate…). Quan trọng không kém, triển khai Distributed Tracing: gán một trace ID duy nhất cho mỗi luồng giao dịch từ Order sang Payment sang Inventory, sử dụng các thư viện OpenTelemetry/Jaeger. Nhờ đó, khi có sự cố (ví dụ đơn hàng đã trừ tiền nhưng tồn kho không cập nhật), kỹ sư có thể truy vết theo ID này để biết lỗi xuất hiện ở service nào, trong bước nào. Hơn nữa, hệ thống nên có các công cụ hỗ trợ vận hành onsite: chẳng hạn một trang admin nội bộ liệt kê các Order đang pending, trạng thái thanh toán, tồn kho theo thời gian thực – để nhân viên có thể chủ động kiểm tra và can thiệp (như thử kích hoạt lại thanh toán bị lỗi, hoặc điều chỉnh tồn kho khẩn cấp) khi cần, thay vì chờ đội phát triển. Về triển khai hạ tầng, dùng container và công cụ orkestration (Docker Compose hoặc Kubernetes tùy quy mô) có thể giúp triển khai và phục hồi dịch vụ dễ dàng (IT onsite chỉ cần chạy script để restart toàn bộ hệ thống nếu cần). Đồng thời, chuẩn bị runbook – tài liệu hướng dẫn các bước xử lý sự cố thường gặp – để đội hỗ trợ tại JW Marriott có thể làm theo nhanh chóng. Mọi thay đổi cấu hình quan trọng nên có cơ chế feature toggle hoặc thiết lập runtime mà IT có thể chỉnh được (thay vì phải sửa code). Nhìn chung, hệ thống được thiết kế để “có thể quan sát và can thiệp”: có đủ thông tin cho người vận hành thấy và đủ công cụ cho phép họ hành động khi gặp tình huống bất thường.
  - Đáp ứng mục tiêu phi chức năng: Thiết kế tập trung vào operability cải thiện đáng kể tính sẵn sàng, khả năng bảo trì và hỗ trợ của hệ thống. Nhờ logs, metrics, traces đầy đủ, đội vận hành có thể phát hiện và chẩn đoán sự cố nhanh – ví dụ cảnh báo tự động khi Payment service không phản hồi, log lỗi chỉ ra nguyên nhân (như timeout kết nối ngân hàng), và trace cho biết giao dịch dừng tại bước nào. Điều này rút ngắn thời gian khôi phục (MTTR), trực tiếp nâng cao độ tin cậy và availability cho hệ thống. Khía cạnh quan sát tốt còn giúp phát hiện sớm các dấu hiệu bất thường trước khi chúng trở thành sự cố nghiêm trọng (ví dụ metric cho thấy số giao dịch lỗi tăng đột biến sẽ báo cho IT kiểm tra dịch vụ thanh toán kịp thời). Tính dễ hỗ trợ onsite đảm bảo nhà hàng có thể tiếp tục vận hành kể cả khi có trục trặc: đội kỹ thuật tại chỗ, với thông tin và công cụ trong tay, có thể tạm thời xử lý (như chuyển sang chế độ offline, nhập liệu thủ công dự phòng) nhằm không gián đoạn dịch vụ khách hàng, sau đó đồng bộ dữ liệu trở lại khi sự cố qua đi. Việc minh bạch hóa luồng sự kiện qua distributed tracing và audit log cũng giúp việc debug và tối ưu hệ thống thuận lợi hơn – các nhà phát triển có thể phối hợp với IT onsite xem lại log/trace để cải tiến hiệu năng hoặc code. Như Kishor Naik đã chỉ ra, một kiến trúc có outbox pattern/log chi tiết sẽ tăng cường khả năng quan sát và đơn giản hóa việc debug/giám sát nhờ luồng sự kiện được làm minh bạch. Tất cả những điều này góp phần xây dựng độ tin cậy hoạt động (operational reliability) cao: hệ thống không chỉ được thiết kế tốt mà còn được vận hành tốt. Cuối cùng, một hệ thống dễ quan sát và hỗ trợ sẽ tiết kiệm chi phí vận hành về lâu dài, khi mà ít phải gọi hỗ trợ ngoài hay downtime, đồng thời tạo sự hài lòng cho người dùng tại JW Marriott vì mọi trục trặc đều được xử lý nhanh chóng, trơn tru.

### b) Kiến trúc mức cao (High-level Architecture)
- **Client apps:** Staff Order App (tablet/web), Admin Portal.
- **Backend services (logical):**
  - Order Service
  - Payment Service (tích hợp PSP/QR/charge-to-room)
  - Inventory Service (recipe, stock movement)
  - Reporting/Query (read models)
- **Data:** transactional DB (OLTP) + (tuỳ chọn) read model/reporting.
- **Integration:** payment gateway/PSP, printer, (tuỳ chọn) JW room-charge interface.

## 10.2 High-level Non-Functional Requirements (NFRs)
- **Availability:** ≥ 99.5% trong giờ vận hành; có plan degraded mode khi mất mạng.
- **Performance:** tạo order < 2s; confirm payment < 3s (trong điều kiện mạng bình thường).
- **Security:** RBAC; audit log bất biến; mã hoá dữ liệu nhạy cảm at-rest/in-transit.
- **Data integrity:** không mất đơn; payment không bị double charge; tồn kho có thể reconcile.
- **Compliance (tuỳ khách):** quy định nội bộ JW/PCI scope (nếu chạm dữ liệu thẻ).

## 10.3 Technical Constraints & Decisions (mức định hướng, chưa chốt công nghệ)
- **Idempotency key** bắt buộc cho API tạo/confirm payment.
- **Outbox pattern** (hoặc tương đương) cho phát sự kiện cập nhật trạng thái liên dịch vụ.
- **Saga/Process manager** cho luồng “payment success but order not updated”.
- **Printer integration**: driver/service cục bộ hoặc cloud print (tuỳ hạ tầng).
- **Offline-first (tùy mức):** queue local + sync khi mạng hồi phục, có conflict policy.

## 10.4 Data & Audit (đầu vào quan trọng của SA)
- **Correlation ID** xuyên suốt: OrderId, PaymentId, InventoryTxnId.
- **Audit log**: ghi lại ai làm gì, lúc nào, trên thiết bị nào.
- **Reconciliation procedures**: báo cáo đối soát thanh toán; đối soát tồn kho.

---

## 11) Tiêu chí chấp nhận mức cao (High-level Acceptance)
- Order/Payment/Inventory chạy end-to-end trên 1 ca vận hành mẫu (happy path + một số exception).
- Không phát sinh double charge trong test tình huống bấm “Pay” nhiều lần.
- Báo cáo đối soát ngày khớp với tổng payments theo từng method.
- Tồn kho trừ đúng theo rule đã thống nhất và có báo cáo reconcile.

---

## 12) Phê duyệt & Ủy quyền (Charter Approval)
- **Sponsor (Khách hàng):** ____________________  Date: ___/___/____
- **Project Manager:** _________________________  Date: ___/___/____
- **Solution Architect:** ________________________  Date: ___/___/____

---

# Phụ lục A — SA Deliverables trong giai đoạn Initiation/Charter (2–3 tuần đầu)

> Mục tiêu: tránh “Charter thiếu kỹ thuật” bằng cách SA cam kết cung cấp các artefact kiến trúc tối thiểu ngay từ giai đoạn khởi tạo dự án, đủ để **chốt phạm vi kỹ thuật**, **làm rõ chất lượng (NFR)**, **giảm rủi ro sớm**, và **tạo nền cho thiết kế/triển khai**.

---

## A.1 Danh mục deliverables (cam kết trong 2–3 tuần đầu)

| # | Deliverable | Kết quả mong đợi | Đầu ra tối thiểu (Definition of Done) |
|---|-------------|------------------|----------------------------------------|
| 1 | System Context Diagram + luồng tích hợp (payment/room charge/printer) | Chốt ranh giới hệ thống, tác nhân, hệ thống xung quanh và các kênh tích hợp | 1 sơ đồ context + 1 trang mô tả interface/channel + 3 luồng tích hợp chính |
| 2 | NFR checklist + acceptance targets | Biến “kỳ vọng mơ hồ” thành mục tiêu kiểm chứng được | Checklist NFR + bảng target/measurement + các giả định & trade-off đã chốt |
| 3 | Sequence diagrams (3 luồng trọng yếu) | Làm rõ hành vi runtime, điểm nhất quán, idempotency, inventory | 3 sequence diagrams + ghi chú invariant, retry, failure handling |
| 4 | Risk register (technical) — Top 10 | “Bắt rủi ro sớm” + plan giảm thiểu theo owner & trigger | 10 rủi ro, mỗi rủi ro có: impact/likelihood/mitigation/owner/trigger |
| 5 | ADR list (khung) | Cố định các quyết định nền và hệ quả dài hạn | 4 ADR “skeleton” (context/options/decision/consequences) + trạng thái |
| 6 | Security & privacy mini threat model (high-level) | Nhìn sớm bề mặt tấn công & biện pháp giảm thiểu | Asset/Trust boundary/Threats/Mitigations + backlog security items |
| 7 | Environment plan: dev/staging/UAT/(on-prem nếu có), logging & monitoring | Giảm rủi ro triển khai/vận hành, tạo vòng phản hồi sớm | Môi trường + dữ liệu test/masking + logging/metrics/alerts + runbook tối thiểu |

---

## A.2 Deliverable 1 — System Context Diagram + luồng tích hợp

### A.2.1 Mục đích
- Làm rõ **system boundary** của “POS/Restaurant Management” cho Milk & Co.
- Thống nhất **các actor/hệ thống liên quan**, **interface**, **kênh kết nối**, và **quy ước dữ liệu** ở mức khởi tạo.

### A.2.2 Nội dung bắt buộc
1. **Business context** (ai dùng, mục tiêu, luồng nghiệp vụ tổng quát).
2. **Technical context** (hệ thống xung quanh + kênh vật lý/kỹ thuật giữa các hệ thống).
3. Danh mục **external interfaces** (in/out), bao gồm:
   - Payment: initiate/capture/void/refund + trạng thái.
   - Room charge: post/adjust/reverse + mapping folio/room/guest.
   - Printer: send/ack/retry + phân tách kitchen/bar/bill.
4. **Assumptions** phải ghi rõ (ví dụ: mạng chập chờn, người dùng bấm “Pay” nhiều lần, thiết bị in đôi khi mất kết nối…).

### A.2.3 Tiêu chí nghiệm thu (acceptance)
- Có **legend**/quy ước ký hiệu; phân biệt rõ **hệ thống nội bộ** vs **bên ngoài**.
- Mỗi integration flow có: trigger, payload tối thiểu, timeout/retry, lỗi thường gặp, trạng thái cuối (success/fail/pending).
- Có bảng **Interface Inventory** (tên interface, direction, SLA/timeout, ownership, dữ liệu nhạy cảm).

---

## A.3 Deliverable 2 — NFR checklist + acceptance targets

### A.3.1 Mục đích
- Chốt các **quality drivers** cho 3 trụ: **Order – Payment – Inventory**.
- Tránh “NFR nói miệng” bằng **target đo được** và **cách kiểm chứng**.

### A.3.2 Checklist NFR (tối thiểu)
- **Availability & resilience:** chịu lỗi mạng, retry, offline/online behavior, degraded mode.
- **Performance:** latency thao tác order/pay/print; throughput theo giờ cao điểm.
- **Data integrity & consistency:** không mất đơn; không trừ kho sai; không double-charge; audit trail.
- **Security & privacy:** xác thực/ủy quyền, bảo vệ dữ liệu thanh toán/PII, logging an toàn.
- **Observability:** log/metric/trace; khả năng truy vết “Order–Payment–Inventory” end-to-end.
- **Operability:** backup/restore, quy trình sự cố, dashboard & alerting.
- **Maintainability & changeability:** tách ranh giới module, interface ổn định, cấu hình/feature flags (nếu dùng).

### A.3.3 Acceptance targets (mẫu khuyến nghị)
> SA điền target cụ thể theo bối cảnh dự án; bên dưới là cấu trúc bắt buộc, không phải giá trị cố định.

- **Order capture durability:** “Không mất đơn” → dữ liệu order phải được ghi bền vững trước khi trả success cho client.
- **Idempotent pay:** 1 order chỉ được “finalize payment” đúng 1 lần theo idempotency key.
- **Print reliability:** ticket quan trọng phải có cơ chế resend/deduplicate để tránh in thiếu hoặc in trùng.
- **Inventory correctness:** trừ kho theo sự kiện “served/closed” với cơ chế đối soát (reconciliation) theo ca/ngày.
- **Auditability:** mọi thay đổi trạng thái order/payment/inventory có event/log bất biến để truy nguyên.

### A.3.4 Tiêu chí nghiệm thu
- Mỗi NFR có: **context–stimulus–response–measurement** (theo dạng quality scenario).
- Có mapping NFR → luồng/điểm chạm kiến trúc → test/monitoring tương ứng.
- Các trade-off được ghi rõ (ví dụ: consistency vs latency; UX vs security).

---

## A.4 Deliverable 3 — Sequence diagrams (3 luồng quan trọng)

> Yêu cầu: diễn đạt **runtime view** của hệ thống và các điểm quyết định (decision points). Không bắt buộc dùng UML chuẩn; được phép dùng dạng text/numbered steps miễn rõ ràng.

### A.4.1 Luồng 1: Create Order → Serve → Close
Bắt buộc thể hiện:
- Actors: Staff/Client UI, Order service, Printer, Inventory.
- Trạng thái order (draft/open/served/closed/cancelled) và **invariants** (ví dụ: “served” không quay lại “open” nếu đã trừ kho).
- Khi nào in ticket, khi nào update trạng thái, và xử lý lỗi in (retry/dedupe).

### A.4.2 Luồng 2: Initiate Pay → Confirm Pay (idempotent) → Close order
Bắt buộc thể hiện:
- Idempotency key (nguồn phát sinh, TTL, scope per order, bảo vệ chống double-click).
- Trường hợp **Payment thành công nhưng Order chưa cập nhật**: chiến lược eventual consistency + audit trail (ví dụ: trạng thái “payment_pending_sync” + cơ chế reconcile).
- Quy tắc “đóng order” chỉ khi nào (payment confirmed? room charge posted? cash accepted?).

### A.4.3 Luồng 3: Order served/closed → inventory deduction → reconciliation
Bắt buộc thể hiện:
- Khi nào phát sinh “inventory deduction event” (served hay closed) và lý do.
- Cơ chế **exactly-once effect** ở tầng business (dedupe theo event-id) để tránh trừ kho trùng.
- Reconciliation theo ca/ngày: nguồn dữ liệu, tiêu chí khớp, xử lý lệch.

### A.4.4 Tiêu chí nghiệm thu
- Mỗi luồng có danh sách: happy path + 3–5 failure modes (timeout, retry, duplicate request, partial failure).
- Chỉ rõ điểm **transaction boundary** và nơi đảm bảo **idempotency / deduplication**.
- Có ghi chú “what to log/measure” cho mỗi bước quan trọng.

---

## A.5 Deliverable 4 — Risk register (technical) — Top 10

### A.5.1 Cấu trúc mỗi rủi ro (bắt buộc)
- **Risk:** mô tả rủi ro kỹ thuật cụ thể.
- **Impact:** ảnh hưởng (business + technical).
- **Likelihood:** xác suất (Low/Med/High).
- **Mitigation:** biện pháp giảm thiểu (thiết kế/kiểm thử/vận hành).
- **Owner:** người chịu trách nhiệm theo dõi.
- **Trigger/Signal:** dấu hiệu xảy ra (metric/log/incident pattern).
- **Residual risk:** rủi ro còn lại sau mitigation.

### A.5.2 Gợi ý Top 10 (mẫu để SA tinh chỉnh)
1. Double-charge do user bấm Pay nhiều lần / network retry.
2. Payment success nhưng order state không cập nhật (split-brain business state).
3. In ticket thất bại/không ổn định → phục vụ sai/thiếu.
4. Trừ kho trùng hoặc trừ sai thời điểm → lệch tồn.
5. Clock/time drift giữa thiết bị → lệch đối soát theo ca.
6. Thiếu audit trail → không truy nguyên được tranh chấp.
7. Permission model mơ hồ → thao tác trái quyền (void/refund/discount).
8. Log chứa dữ liệu nhạy cảm → rủi ro privacy/compliance.
9. Sự cố môi trường (staging/UAT không giống prod) → lỗi chỉ lộ khi go-live.
10. Thiếu quan sát end-to-end → MTTR cao khi có incident.

### A.5.3 Tiêu chí nghiệm thu
- Mỗi rủi ro có ít nhất 1 **mitigation cụ thể** gắn với deliverable/epic.
- Có thứ tự ưu tiên theo risk exposure (Impact × Likelihood).

---

## A.6 Deliverable 5 — ADR list (khung)

### A.6.1 Mục đích
- Ghi nhận quyết định kiến trúc sớm để tránh “quyết định truyền miệng”, và làm rõ **hệ quả dài hạn**.

### A.6.2 Template ADR (tối thiểu)
- **Title / Status / Date**
- **Context & Problem**
- **Decision Drivers (quality/constraints)**
- **Options considered**
- **Decision**
- **Consequences (positive/negative)**
- **Open questions / Follow-ups**

### A.6.3 Danh sách ADR tối thiểu trong giai đoạn Charter
1. **Idempotency strategy:** phạm vi key, lưu trữ, TTL, nơi enforce, retry semantics.
2. **Consistency strategy:** khi nào strong vs eventual; reconcile; source of truth cho order/payment/inventory.
3. **Data ownership:** hệ nào sở hữu trạng thái order, payment record, inventory ledger; mapping & contract.
4. **Observability:** correlation-id, event schema tối thiểu, log/metric/trace & retention, audit trail.

### A.6.4 Tiêu chí nghiệm thu
- Mỗi ADR có ít nhất 2 option + rationale.
- ADR nêu rõ “what changes later” và rủi ro khi thay đổi.

---

## A.7 Deliverable 6 — Security & privacy mini threat model (high-level)

### A.7.1 Phạm vi
- Assets tối thiểu: **order data**, **payment status**, **room charge identifiers**, **staff identity/roles**, **inventory ledger**, **logs/audit**.
- Trust boundaries: client devices, network, backend services, external payment/room-charge/printer endpoints.

### A.7.2 Output bắt buộc
- **Asset list** + mức độ nhạy cảm.
- **Entry points** (API/UI/Printer channel).
- **Threat list** theo nhóm (mạo danh, sửa dữ liệu, từ chối giao dịch, lộ dữ liệu, gián đoạn dịch vụ…).
- **Mitigation**: authn/authz, least privilege, secure logging, key management (mức nguyên tắc), rate limiting, tamper-evident audit trail.
- **Security backlog**: 5–10 action items ưu tiên.

### A.7.3 Tiêu chí nghiệm thu
- Có mapping Threat → Mitigation → nơi kiểm chứng (test/monitoring).
- Nêu rõ dữ liệu nào **không được log** và quy tắc masking.

---

## A.8 Deliverable 7 — Environment plan (dev/staging/UAT/(on-prem nếu cần), logging & monitoring)

### A.8.1 Mục đích
- Tạo môi trường để kiểm chứng NFR sớm; giảm “works on my machine”.
- Chuẩn bị khả năng vận hành: quan sát, cảnh báo, runbook tối thiểu.

### A.8.2 Nội dung bắt buộc
1. **Môi trường & mục đích**
   - Dev: tốc độ dev, dữ liệu giả lập.
   - Staging: kiểm thử tích hợp & smoke, config gần prod.
   - UAT: kiểm thử nghiệp vụ + kịch bản ca/kết sổ.
   - Prod: vận hành thực tế.
   - (On-prem nếu cần): mô tả ràng buộc mạng/thiết bị, quy trình triển khai tại chỗ.
2. **Data strategy**
   - Seed data, data masking/anonymization, reset policy.
3. **Logging/Monitoring**
   - Correlation id xuyên suốt order-payment-inventory.
   - Dashboard tối thiểu: success rate, latency, payment mismatch, print retry, inventory reconciliation diff.
   - Alerting: ngưỡng & escalation.
4. **Release & rollback**
   - Versioning, backward compatibility cho interface/event schema.
5. **Runbook tối thiểu**
   - Các bước xử lý: payment mismatch, printer down, reconcile inventory, re-sync room charge.

### A.8.3 Tiêu chí nghiệm thu
- Staging/UAT mô phỏng được các failure modes quan trọng (timeout/duplicate request/printer offline).
- Có checklist go-live tối thiểu và tiêu chí “ready for pilot”.

---

## A.9 Giao ước phối hợp (nhanh gọn)

- **SA** chịu trách nhiệm: nội dung kiến trúc, quyết định & trade-off, tiêu chí đo/kiểm chứng, và tính nhất quán giữa deliverables.
- **PO/Stakeholders** chịu trách nhiệm: xác nhận mục tiêu kinh doanh, ưu tiên quality drivers, và quyết định các trade-off có tác động nghiệp vụ.
- **Dev/QA/Ops** tham gia phản hồi: khả thi triển khai/kiểm thử/vận hành, cung cấp constraint thực tế và xác nhận DoD kỹ thuật.

---

## A.10 Phụ lục biểu mẫu (copy/paste)

### A.10.1 Interface Inventory (mẫu)
- Interface name:
- Direction (in/out):
- Trigger:
- Payload (min fields):
- Timeout/Retry:
- Idempotency/Dedup:
- Security/Privacy notes:
- Owner (system/team):

### A.10.2 Risk Register row (mẫu)
- Risk:
- Impact:
- Likelihood:
- Mitigation:
- Owner:
- Trigger/Signal:
- Residual risk:

### A.10.3 ADR skeleton (mẫu)
- Title:
- Status:
- Context:
- Decision drivers:
- Options:
- Decision:
- Consequences:
- Follow-ups:

# Phụ lục B — Glossary ngắn
- **Idempotency:** cùng một yêu cầu gửi lại nhiều lần nhưng kết quả chỉ được tính một lần.
- **Outbox pattern:** ghi sự kiện vào DB cùng transaction rồi phát ra message để đồng bộ hệ thống khác.
- **Saga:** phối hợp nhiều bước giữa các service, có cơ chế bù trừ khi lỗi.
